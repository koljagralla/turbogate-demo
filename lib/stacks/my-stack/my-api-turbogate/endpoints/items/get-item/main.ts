// Generated by turbogate (v2.0.2)
// BEFORE EDITING: Please read turbogate docs and the following caveats.
// Purpose of thise file:           This is the main function of the endpoint. Use this to implement your custom business logic. All provided parameters have been prevalidated.
// Expected signature:              export async function main( environment: Environment, request: Request, authorizerContext: AuthorizerContext, ): Promise<Response>
// Can be edited?                   Yes, editing this file is intended. Please ensure to preserve the signature though.
// Can be permanently deleted?      No, generated code will break (so technically yes, if you fix loads of errors but you probably should not).
// Will be recreated?               If you delete this file and run `turbogate build` a boilerplate version of this file will be recreated.
import { HttpStatus } from 'turbogate';
import { AuthorizerContext } from './authorizer';
import { Environment } from './environment';
import { Request } from './request';
import { Response } from './responses';
import { Context } from 'aws-lambda';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, GetCommand } from '@aws-sdk/lib-dynamodb';
import { zItemRecord } from '../../../../database/items/item-record';

const client = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(client);

export async function main(
  environment: Environment,
  request: Request,
  authorizerContext: AuthorizerContext,
  lambdaContext: Context,
): Promise<Response> {
  try {
    // Fetch the item from the DB
    const res = await docClient.send(
      new GetCommand({
        TableName: environment.ITEMS_TABLE_NAME,
        Key: {
          id: request.pathParameters.id,
        },
      }),
    );

    // Check if the item exists
    if (!res.Item) {
      return {
        statusCode: HttpStatus.NotFound,
      };
    }

    // Verify the item data
    // Depending on the trust in the integrity of your DB data you could also skip parsing to increase performance a bit.
    const item = zItemRecord.parse(res.Item);

    // Return the item
    return {
      statusCode: HttpStatus.OK,
      body: item,
    };
  } catch (e) {
    // Handle errors
    console.error('Failed to fetch item', e);
    return {
      statusCode: HttpStatus.InternalServerError,
      body: undefined,
    };
  }
}
